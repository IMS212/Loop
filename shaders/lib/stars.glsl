// Original star code : https://www.shadertoy.com/view/Md2SR3 , optimised

float random10(vec2 ab)
{
    float f = (cos(dot(ab, vec2(21.9898, 78.233))) * 43758.5453);
    return fract(f);
}

float noise10(in vec2 xy)
{
    vec2 ij = floor(xy);
    vec2 uv = xy - ij;
    uv = uv * uv * (3.0 - 2.0 * uv);

    float a = random10(vec2(ij.x, ij.y));
    float b = random10(vec2(ij.x + 1., ij.y));
    float c = random10(vec2(ij.x, ij.y + 1.));
    float d = random10(vec2(ij.x + 1., ij.y + 1.));
    float k0 = a;
    float k1 = b - a;
    float k2 = c - a;
    float k3 = a - b - c + d;
    return (k0 + k1 * uv.x + k2 * uv.y + k3 * uv.x * uv.y);
}

// Return random noise in the range [0.0, 1.0], as a function of x.
float hash12(vec2 p)
{
    vec3 p3 = fract(vec3(p.xyx) * 0.1031);
    p3 += dot(p3, p3.yzx + 19.19);
    return fract((p3.x + p3.y) * p3.z);
}
// Convert Noise2d() into a "star field" by stomping everthing below fThreshhold to zero.
float NoisyStarField(in vec2 vSamplePos, float fThreshhold)
{
    float StarVal = hash12(vSamplePos);
    StarVal = clamp(StarVal / (1.0 - fThreshhold) - fThreshhold / (1.0 - fThreshhold), 0.0, 1.0);

    return StarVal;
}

// Stabilize NoisyStarField() by only sampling at integer values.
float StableStarField(in vec2 vSamplePos, float fThreshhold)
{
    // Linear interpolation between four samples.
    // Note: This approach has some visual artifacts.
    // There must be a better way to "anti alias" the star field.
    float fractX = fract(vSamplePos.x);
    float fractY = fract(vSamplePos.y);
    vec2 floorSample = floor(vSamplePos);
    float v1 = NoisyStarField(floorSample, fThreshhold);
    float v2 = NoisyStarField(floorSample + vec2(0.0, 1.0), fThreshhold);
    float v3 = NoisyStarField(floorSample + vec2(1.0, 0.0), fThreshhold);
    float v4 = NoisyStarField(floorSample + vec2(1.0, 1.0), fThreshhold);

    float StarVal = v1 * (1.0 - fractX) * (1.0 - fractY) + v2 * (1.0 - fractX) * fractY + v3 * fractX * (1.0 - fractY) +
                    v4 * fractX * fractY;
    return StarVal;
}

float stars(vec3 fragpos)
{

    float elevation = clamp(fragpos.y, 0., 1.);
    vec2 uv = fragpos.xz / (1. + elevation);

    return clamp(StableStarField(uv * 700., 0.99) * 0.5 - 0.2 * (0.3 - 0.3 * rainStrength), 0, 1) * 0.1;
}
